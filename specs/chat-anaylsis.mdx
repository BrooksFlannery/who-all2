# Chat Analysis & Event Recommendation System Technical Specification

## Overview

This document outlines the technical implementation of a chat analysis system that extracts user interests from conversations and provides personalized event recommendations using AI-powered analysis and semantic matching with **proper tool calls**.

## System Architecture

### Core Components

1. **Interest Extraction Tool** - AI tool that analyzes user messages for expressed interests
2. **Event Recommendation Tool** - AI tool that provides personalized event suggestions
3. **Database Schema Extensions** - New tables and fields for interest tracking
4. **AI Integration** - Vercel AI SDK with proper tool calls
5. **Unified Chat Flow** - Single streamText call with multiple tools

## Database Schema Changes

### New Tables Required

#### 1. `user_interest` Table
```sql
CREATE TABLE user_interest (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL REFERENCES user(id) ON DELETE CASCADE,
    keyword TEXT NOT NULL,
    confidence_score DECIMAL(3,2) NOT NULL CHECK (confidence_score >= 0 AND confidence_score <= 1),
    specificity_score DECIMAL(3,2) NOT NULL CHECK (specificity_score >= 0 AND specificity_score <= 1),
    source_message_id UUID REFERENCES message(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, keyword)
);
```

#### 2. `event_keyword` Table
```sql
CREATE TABLE event_keyword (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id UUID NOT NULL REFERENCES event(id) ON DELETE CASCADE,
    keyword TEXT NOT NULL,
    weight DECIMAL(3,2) DEFAULT 1.0 CHECK (weight >= 0 AND weight <= 1),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(event_id, keyword)
);
```

#### 3. `user_event_recommendation` Table
```sql
CREATE TABLE user_event_recommendation (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL REFERENCES user(id) ON DELETE CASCADE,
    event_id UUID NOT NULL REFERENCES event(id) ON DELETE CASCADE,
    recommendation_score DECIMAL(5,4) NOT NULL,
    shown_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    user_feedback TEXT, -- 'interested', 'not_interested', 'going', null
    UNIQUE(user_id, event_id)
);
```

### Schema Modifications

#### 1. Update `event` Table
Add keywords field to existing events:
```sql
ALTER TABLE event ADD COLUMN keywords TEXT[] DEFAULT '{}';
```

#### 2. Update `user_profile` Table
Add interest tracking fields:
```sql
ALTER TABLE user_profile ADD COLUMN last_interest_analysis TIMESTAMP WITH TIME ZONE;
ALTER TABLE user_profile ADD COLUMN interest_analysis_version INTEGER DEFAULT 1;
```

## AI Tool Implementation

### Tool 1: Extract Interests Tool

**Purpose**: Analyze user messages for expressed interests and store them in the database.

**Tool Definition**:
```typescript
extractInterests: tool({
    description: "Extract user interests from messages when users share hobbies, activities, or preferences. Call this to learn about what users enjoy.",
    parameters: z.object({
        userMessage: z.string().describe('The user message to analyze for interests'),
    }),
    execute: async ({ userMessage }) => {
        // 1. Use OpenAI to analyze message for interests
        // 2. Store interests in database
        // 3. Return summary of what was learned
    }
})
```

**Implementation**:
```typescript
async function extractUserInterests(message: string, userId: string, messageId: string): Promise<string> {
    // 1. Use OpenAI to analyze message for interests
    const result = await generateText({
        model: openai('gpt-4o-mini'),
        messages: [
            {
                role: 'system',
                content: `Analyze the following user message for expressed interests, hobbies, activities, or preferences. 
Return a JSON object with:
- interests: array of interest objects with keyword, confidence_score (0-1), and specificity_score (0-1)
- has_interests: boolean indicating if any interests were found

Guidelines:
- confidence_score: How certain you are this is an actual interest (not just mentioned)
- specificity_score: How specific/niche the interest is (e.g., "rock climbing" vs "sports")
- Extract both explicit ("I love hiking") and implicit ("I'm training for a marathon") interests
- Focus on activities, hobbies, skills, and preferences that could relate to events
- Ignore dislikes or negative preferences for now (MVP scope)

Message: "${message}"

Return only valid JSON.`
            }
        ]
    });

    // 2. Parse and store interests
    const parsed = JSON.parse(result.text);
    if (parsed.has_interests && parsed.interests.length > 0 && db) {
        for (const interest of parsed.interests) {
            await db.insert(userInterest).values({
                userId: userId,
                keyword: interest.keyword,
                confidenceScore: interest.confidence_score.toString(),
                specificityScore: interest.specificity_score.toString(),
                sourceMessageId: messageId
            });
        }
    }

    // 3. Return conversational summary
    if (parsed.has_interests && parsed.interests.length > 0) {
        const interests = parsed.interests.map(i => i.keyword).join(', ');
        return `I learned that you're interested in: ${interests}. I'll keep this in mind for future recommendations!`;
    } else {
        return `I didn't detect any specific interests in that message, but I'm here to learn more about what you enjoy!`;
    }
}
```

### Tool 2: Get Recommendations Tool

**Purpose**: Provide personalized event recommendations based on user interests.

**Tool Definition**:
```typescript
getRecommendations: tool({
    description: "Get personalized event recommendations when users ask for suggestions, events, or activities. Call this to provide relevant event suggestions.",
    parameters: z.object({
        userMessage: z.string().describe('The user message requesting recommendations'),
    }),
    execute: async ({ userMessage }) => {
        // 1. Fetch user interests and events
        // 2. Calculate similarity scores
        // 3. Return formatted recommendations
    }
})
```

**Implementation**:
```typescript
async function getEventRecommendations(userId: string, limit: number = 3): Promise<string> {
    // 1. Fetch user interests
    const userInterests = await db
        .select()
        .from(userInterest)
        .where(eq(userInterest.userId, userId));

    // 2. Fetch events (excluding previously shown)
    const events = await db
        .select()
        .from(event)
        .where(/* exclude shown events */);

    // 3. Calculate similarity scores using embeddings
    const scores = await calculateSimilarityScores(
        userInterests.map(i => i.keyword),
        events.map(e => e.keywords).flat()
    );

    // 4. Apply scoring formula and return top results
    const recommendations = events
        .map((event, index) => ({
            event,
            score: scores[index]
        }))
        .sort((a, b) => b.score - a.score)
        .slice(0, limit);

    // 5. Return conversational response
    if (recommendations.length > 0) {
        const eventList = recommendations.map(r => 
            `• ${r.event.title} - ${r.event.description}`
        ).join('\n');
        return `Here are some events that might interest you:\n\n${eventList}\n\nWould you like to know more about any of these?`;
    } else {
        return `I don't have any events to recommend right now, but I'm working on finding more activities that match your interests!`;
    }
}
```

## Unified Chat API Implementation

### Single streamText Call with Tools

```typescript
export async function POST(req: Request) {
    const session = await auth.api.getSession({ headers: req.headers });
    if (!session?.user?.id) {
        return new Response("Unauthorized", { status: 401 });
    }

    const { messages } = await req.json();
    
    // Save user message
    const [savedMessage] = await db.insert(message).values({
        userId: session.user.id,
        content: messages[messages.length - 1].content,
        role: "user"
    }).returning({ id: message.id });

    const result = streamText({
        model: openai('gpt-4o-mini'),
        messages: [
            {
                role: "system",
                content: `You are a friendly and helpful assistant that helps users discover events and activities. 

IMPORTANT GUIDELINES:
- Be conversational, warm, and engaging in your responses
- When users share their interests, hobbies, or activities, use the extractInterests tool to learn about them
- When users ask for recommendations, suggestions, or events, use the getRecommendations tool
- Ask follow-up questions to understand their preferences better
- Keep responses natural and conversational - don't sound like a robot
- Always acknowledge when you learn new interests about them

Your goal is to help users discover events that match their interests by having natural conversations and understanding what they enjoy.`
            },
            ...messages,
        ],
        tools: {
            extractInterests: tool({
                description: "Extract user interests from messages when users share hobbies, activities, or preferences. Call this to learn about what users enjoy.",
                parameters: z.object({
                    userMessage: z.string().describe('The user message to analyze for interests'),
                }),
                execute: async ({ userMessage }) => {
                    return extractUserInterests(userMessage, session.user.id, savedMessage.id);
                }
            }),
            getRecommendations: tool({
                description: "Get personalized event recommendations when users ask for suggestions, events, or activities. Call this to provide relevant event suggestions.",
                parameters: z.object({
                    userMessage: z.string().describe('The user message requesting recommendations'),
                }),
                execute: async ({ userMessage }) => {
                    return getEventRecommendations(session.user.id, 3);
                }
            })
        },
        onFinish: async (completion) => {
            // Save AI response
            await db.insert(message).values({
                userId: session.user.id,
                content: completion.text,
                role: "assistant"
            });
        },
    });

    return result.toDataStreamResponse();
}
```

## Data Flow

### Natural Conversation Flow
1. User sends message
2. Message saved to database
3. AI analyzes message and decides what tools to call
4. If interests detected → calls extractInterests tool
5. If recommendations requested → calls getRecommendations tool
6. AI responds conversationally with tool results
7. AI response saved to database

### Tool Call Examples

**User says:** "I love rock climbing and hiking"
```
AI: "That's awesome! I love that you're into outdoor activities. I learned that you're interested in: rock climbing, hiking. I'll keep this in mind for future recommendations!"
```

**User says:** "Can you recommend some events?"
```
AI: "Absolutely! Here are some events that might interest you:

• Morning Running Club - Join our weekly running group! All paces welcome.
• Outdoor Adventure Meetup - Hiking and rock climbing for all skill levels.
• Weekend Hiking Group - Explore local trails with fellow outdoor enthusiasts.

Would you like to know more about any of these?"
```

## Implementation Phases

### Phase 1: Database Setup
1. Create database migrations
2. Manually assign keywords to seed events
3. Test database schema

### Phase 2: Core Functions
1. Implement extractUserInterests function
2. Implement getEventRecommendations function
3. Add embedding functionality

### Phase 3: Tool Integration
1. Replace current chat API with unified tool-based approach
2. Test tool calls and responses
3. Verify conversation flow

### Phase 4: Optimization
1. Add caching for embeddings
2. Optimize recommendation algorithm
3. Add user feedback collection

## Key Benefits of Tool-Based Approach

1. **Natural conversation flow** - AI decides when to extract interests or get recommendations
2. **No hardcoded logic** - No more `includes('recommend')` bullshit
3. **Single code path** - One streamText call handles everything
4. **Better user experience** - AI can extract interests naturally during conversation
5. **Easier to extend** - Just add new tools as needed
6. **Cleaner code** - Each tool has one job, clear separation of concerns

## Error Handling

### Tool Execution Errors
- Graceful degradation if tools fail
- Fallback responses for recommendation failures
- Log errors for debugging

### Conversation Flow
- AI handles edge cases naturally
- No manual flow control needed
- Tool calls are optional and contextual

## Testing Strategy

### Tool Testing
- Test each tool independently
- Verify database operations
- Test error scenarios

### Integration Testing
- End-to-end conversation flow
- Tool call integration
- Natural language understanding

### User Testing
- Interest detection accuracy
- Recommendation relevance
- Conversation naturalness
