# Chat Analysis & Event Recommendation System Technical Specification

## Overview

This document outlines the technical implementation of a chat analysis system that extracts user interests from conversations and provides personalized event recommendations using AI-powered analysis and semantic matching with **proper tool calls**.

## System Architecture

### Core Components

1. **Interest Extraction Tool** - AI tool that analyzes user messages for expressed interests
2. **Event Recommendation Tool** - AI tool that provides personalized event suggestions
3. **Database Schema Extensions** - New tables and fields for interest tracking
4. **AI Integration** - Vercel AI SDK with proper tool calls
5. **Unified Chat Flow** - Single streamText call with multiple tools

## Database Schema Changes

### New Tables Required

#### 1. `user_interest` Table
```sql
CREATE TABLE user_interest (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL REFERENCES user(id) ON DELETE CASCADE,
    keyword TEXT NOT NULL,
    confidence_score DECIMAL(3,2) NOT NULL CHECK (confidence_score >= 0 AND confidence_score <= 1),
    specificity_score DECIMAL(3,2) NOT NULL CHECK (specificity_score >= 0 AND specificity_score <= 1),
    source_message_id UUID REFERENCES message(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, keyword)
);
```

#### 2. `event_keyword` Table
```sql
CREATE TABLE event_keyword (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id UUID NOT NULL REFERENCES event(id) ON DELETE CASCADE,
    keyword TEXT NOT NULL,
    weight DECIMAL(3,2) DEFAULT 1.0 CHECK (weight >= 0 AND weight <= 1),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(event_id, keyword)
);
```

#### 3. `user_event_recommendation` Table
```sql
CREATE TABLE user_event_recommendation (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL REFERENCES user(id) ON DELETE CASCADE,
    event_id UUID NOT NULL REFERENCES event(id) ON DELETE CASCADE,
    recommendation_score DECIMAL(5,4) NOT NULL,
    shown_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    user_feedback TEXT, -- 'interested', 'not_interested', 'going', null
    UNIQUE(user_id, event_id)
);
```

### Schema Modifications

#### 1. Update `event` Table
Add keywords field to existing events:
```sql
ALTER TABLE event ADD COLUMN keywords TEXT[] DEFAULT '{}';
```

#### 2. Update `user_profile` Table
Add interest tracking fields:
```sql
ALTER TABLE user_profile ADD COLUMN last_interest_analysis TIMESTAMP WITH TIME ZONE;
ALTER TABLE user_profile ADD COLUMN interest_analysis_version INTEGER DEFAULT 1;
```

## AI Tool Implementation

### Tool 1: Extract Interests Tool

**Purpose**: Analyze user messages for expressed interests and store them in the database.

**Tool Definition**:
```typescript
extractInterests: tool({
    description: "Extract user interests from messages when users share hobbies, activities, or preferences. Call this to learn about what users enjoy.",
    parameters: z.object({
        userMessage: z.string().describe('The user message to analyze for interests'),
    }),
    execute: async ({ userMessage }) => {
        // 1. Use OpenAI to analyze message for interests
        // 2. Store interests in database
        // 3. Return summary of what was learned
    }
})
```

**Implementation**:
```typescript
async function extractUserInterests(message: string, userId: string, messageId: string): Promise<string> {
    // 1. Use OpenAI to analyze message for interests
    const result = await generateText({
        model: openai('gpt-4o-mini'),
        messages: [
            {
                role: 'system',
                content: `Analyze the following user message for expressed interests, hobbies, activities, or preferences. 
Return a JSON object with:
- interests: array of interest objects with keyword, confidence_score (0-1), and specificity_score (0-1)
- has_interests: boolean indicating if any interests were found

Guidelines:
- confidence_score: How certain you are this is an actual interest (not just mentioned)
- specificity_score: How specific/niche the interest is (e.g., "rock climbing" vs "sports")
- Extract both explicit ("I love hiking") and implicit ("I'm training for a marathon") interests
- Focus on activities, hobbies, skills, and preferences that could relate to events
- Ignore dislikes or negative preferences for now (MVP scope)

Message: "${message}"

Return only valid JSON.`
            }
        ]
    });

    // 2. Parse and store interests
    const parsed = JSON.parse(result.text);
    if (parsed.has_interests && parsed.interests.length > 0 && db) {
        for (const interest of parsed.interests) {
            await db.insert(userInterest).values({
                userId: userId,
                keyword: interest.keyword,
                confidenceScore: interest.confidence_score.toString(),
                specificityScore: interest.specificity_score.toString(),
                sourceMessageId: messageId
            });
        }
    }

    // 3. Return conversational summary
    if (parsed.has_interests && parsed.interests.length > 0) {
        const interests = parsed.interests.map(i => i.keyword).join(', ');
        return `I learned that you're interested in: ${interests}. I'll keep this in mind for future recommendations!`;
    } else {
        return `I didn't detect any specific interests in that message, but I'm here to learn more about what you enjoy!`;
    }
}
```

### Tool 2: Get Recommendations Tool

**Purpose**: Provide personalized event recommendations based on user interests.

**Tool Definition**:
```typescript
getRecommendations: tool({
    description: "Get personalized event recommendations when users ask for suggestions, events, or activities. Call this to provide relevant event suggestions.",
    parameters: z.object({
        userMessage: z.string().describe('The user message requesting recommendations'),
    }),
    execute: async ({ userMessage }) => {
        // 1. Fetch user interests and events
        // 2. Calculate similarity scores
        // 3. Return top 3 events with full data
    }
})
```

**Return Format**:
```typescript
interface RecommendationResponse {
    events: Event[];
    message: string;
    success: boolean;
    error?: string;
}
```

**Implementation**:
```typescript
async function getEventRecommendations(userId: string, limit: number = 3): Promise<RecommendationResponse> {
    try {
        // 1. Fetch user interests
        const userInterests = await db
            .select()
            .from(userInterest)
            .where(eq(userInterest.userId, userId));

        // 2. Fetch events (excluding previously shown)
        const events = await db
            .select()
            .from(event)
            .where(/* exclude shown events */);

        // 3. Calculate similarity scores using embeddings
        const scores = await calculateSimilarityScores(
            userInterests.map(i => i.keyword),
            events.map(e => e.keywords).flat()
        );

        // 4. Apply scoring formula and return top results
        const recommendations = events
            .map((event, index) => ({
                event,
                score: scores[index]
            }))
            .sort((a, b) => b.score - a.score)
            .slice(0, limit);

        // 5. Return events and conversational message
        if (recommendations.length > 0) {
            return {
                events: recommendations.map(r => r.event),
                message: `I found ${recommendations.length} events that might interest you!`,
                success: true
            };
        } else {
            return {
                events: [],
                message: "I don't have any events to recommend right now, but I'm working on finding more activities that match your interests!",
                success: true
            };
        }
    } catch (error) {
        console.error('Error in getEventRecommendations:', error);
        return {
            events: [],
            message: "I'm having trouble finding events right now, but I'm working on it!",
            success: false,
            error: error.message
        };
    }
}
```

## Unified Chat API Implementation

### Single streamText Call with Tools

```typescript
export async function POST(req: Request) {
    const session = await auth.api.getSession({ headers: req.headers });
    if (!session?.user?.id) {
        return new Response("Unauthorized", { status: 401 });
    }

    const { messages } = await req.json();
    
    // Save user message
    const [savedMessage] = await db.insert(message).values({
        userId: session.user.id,
        content: messages[messages.length - 1].content,
        role: "user"
    }).returning({ id: message.id });

    const result = streamText({
        model: openai('gpt-4o-mini'),
        messages: [
            {
                role: "system",
                content: `You are a friendly and helpful assistant that helps users discover events and activities. 

IMPORTANT GUIDELINES:
- Be conversational, warm, and engaging in your responses
- When users share their interests, hobbies, or activities, use the extractInterests tool to learn about them
- When users ask for recommendations, suggestions, or events, use the getRecommendations tool
- Ask follow-up questions to understand their preferences better
- Keep responses natural and conversational - don't sound like a robot
- Always acknowledge when you learn new interests about them

Your goal is to help users discover events that match their interests by having natural conversations and understanding what they enjoy.`
            },
            ...messages,
        ],
        tools: {
            extractInterests: tool({
                description: "Extract user interests from messages when users share hobbies, activities, or preferences. Call this to learn about what users enjoy.",
                parameters: z.object({
                    userMessage: z.string().describe('The user message to analyze for interests'),
                }),
                execute: async ({ userMessage }) => {
                    return extractUserInterests(userMessage, session.user.id, savedMessage.id);
                }
            }),
            getRecommendations: tool({
                description: "Get personalized event recommendations when users ask for suggestions, events, or activities. Call this to provide relevant event suggestions.",
                parameters: z.object({
                    userMessage: z.string().describe('The user message requesting recommendations'),
                }),
                execute: async ({ userMessage }) => {
                    return getEventRecommendations(session.user.id, 3);
                }
            })
        },
        onFinish: async (completion) => {
            // Save AI response
            await db.insert(message).values({
                userId: session.user.id,
                content: completion.text,
                role: "assistant"
            });
        },
    });

    return result.toDataStreamResponse();
}
```

## Data Flow

### Natural Conversation Flow
1. User sends message
2. Message saved to database
3. AI analyzes message and decides what tools to call
4. If interests detected → calls extractInterests tool
5. If recommendations requested → calls getRecommendations tool
6. AI responds conversationally with tool results
7. AI response saved to database

### Tool Call Examples

**User says:** "I love rock climbing and hiking"
```
AI: "That's awesome! I love that you're into outdoor activities. I learned that you're interested in: rock climbing, hiking. I'll keep this in mind for future recommendations!"
```

**User says:** "Can you recommend some events?"
```
AI: "Absolutely! I found 3 events that might interest you!"

[Event Cards displayed inline with same format as Events screen]
```

## Chat UI Integration

### Event Display in Chat

**Event Cards**: Events are displayed inline in chat messages using the same card format as the Events screen:
- Event title and description
- Date and time
- Category badges with colors
- Location (neighborhood)
- Attendee/interested counts

**Message Structure**: When the AI calls `getRecommendations`, the response includes:
1. **AI Text Response**: Conversational flavor text about the events
2. **Event Data**: Full event objects for frontend rendering

**Frontend Implementation**:
```typescript
// Chat message component
interface ChatMessage {
    id: string;
    role: 'user' | 'assistant';
    content: string;
    events?: Event[]; // Optional event data for assistant messages
    timestamp: Date;
}

// Render events inline with AI response
const renderAssistantMessage = (message: ChatMessage) => (
    <View>
        <Text>{message.content}</Text>
        {message.events && (
            <View style={styles.eventsContainer}>
                {message.events.map(event => (
                    <EventCard key={event.id} event={event} />
                ))}
            </View>
        )}
    </View>
);
```

### Event Card Component

The event cards in chat should use the same component as the Events screen:

```typescript
// Reuse existing EventCard component
import { EventCard } from '@/components/EventCard';

// In chat message
{message.events?.map(event => (
    <EventCard 
        key={event.id} 
        event={event}
        onPress={() => handleEventPress(event)}
        compact={true} // Optional: more compact for chat
    />
))}
```

### Styling for Chat Context

```typescript
const styles = StyleSheet.create({
    eventsContainer: {
        marginTop: 12,
        gap: 12,
    },
    eventCard: {
        // Same as Events screen but with chat-specific adjustments
        marginHorizontal: 0, // Remove horizontal padding in chat
        borderRadius: 12, // Slightly smaller radius for chat
    }
});
```

## Implementation Phases

### Phase 1: Database Setup
1. Create database migrations
2. Manually assign keywords to seed events
3. Test database schema

### Phase 2: Core Functions
1. Implement extractUserInterests function
2. Implement getEventRecommendations function (returns event data)
3. Add embedding functionality

### Phase 3: Tool Integration
1. Replace current chat API with unified tool-based approach
2. Update getRecommendations to return full event objects
3. Test tool calls and responses

### Phase 4: UI Integration
1. Update chat components to display event cards
2. Implement inline event rendering
3. Add event card styling to match Events screen

### Phase 5: Optimization
1. Add caching for embeddings
2. Optimize recommendation algorithm
3. Add user feedback collection

## Key Benefits of Tool-Based Approach

1. **Natural conversation flow** - AI decides when to extract interests or get recommendations
2. **No hardcoded logic** - No more `includes('recommend')` bullshit
3. **Single code path** - One streamText call handles everything
4. **Better user experience** - AI can extract interests naturally during conversation
5. **Easier to extend** - Just add new tools as needed
6. **Cleaner code** - Each tool has one job, clear separation of concerns

## Error Handling

### Tool Execution Errors
- Graceful degradation if tools fail
- Fallback responses for recommendation failures
- Log errors for debugging

### Conversation Flow
- AI handles edge cases naturally
- No manual flow control needed
- Tool calls are optional and contextual

## Testing Strategy

### Tool Testing
- Test each tool independently
- Verify database operations
- Test error scenarios

### Integration Testing
- End-to-end conversation flow
- Tool call integration
- Natural language understanding

### User Testing
- Interest detection accuracy
- Recommendation relevance
- Conversation naturalness

## Error Handling & Edge Cases

### Tool Execution Errors
- If `extractInterests` fails: Continue conversation without storing interests
- If `getRecommendations` fails: Return error message, don't show events
- If embeddings fail: Fall back to popularity-based recommendations

### Empty States
- No user interests: Show popular events
- No events available: Show "no events" message
- No matching events: Show top 3 events anyway (as per requirements)

### Data Validation
- Validate event data before sending to frontend
- Handle missing event fields gracefully
- Ensure event cards render even with incomplete data

## Performance Considerations

### Embedding Optimization
- Cache embeddings for frequently used keywords
- Batch embedding requests when possible
- Consider pre-computing embeddings for event keywords

### Database Queries
- Optimize user interest queries with proper indexing
- Use efficient queries for event recommendations
- Consider pagination for large event sets

### Frontend Performance
- Lazy load event cards if many events
- Optimize re-renders with proper React keys
- Consider virtual scrolling for long chat histories
