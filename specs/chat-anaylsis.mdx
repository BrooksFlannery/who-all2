# Chat Analysis & Event Matching - Technical Specification

## Overview
Enhance the AI chat interface to intelligently match users with relevant events based on their interests and conversation context. The system will extract user preferences, match them against event keywords using semantic search, and present personalized event recommendations in the chat interface.

## Core Architecture

### 1. Database Schema Changes

#### Events Table Enhancement
```sql
-- Add keywords field to existing event table
ALTER TABLE event ADD COLUMN keywords TEXT[] DEFAULT '{}';
ALTER TABLE event ADD COLUMN keyword_scores JSONB DEFAULT '{}';
```

#### User Profile Enhancement
```sql
-- Add interests field to existing user_profile table
ALTER TABLE user_profile ADD COLUMN interests JSONB DEFAULT '{}';
ALTER TABLE user_profile ADD COLUMN interest_scores JSONB DEFAULT '{}';
ALTER TABLE user_profile ADD COLUMN last_interest_update TIMESTAMP DEFAULT NOW();
```

#### New Table: Event Recommendations
```sql
-- Track which events have been recommended to users
CREATE TABLE event_recommendation (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id TEXT NOT NULL REFERENCES user(id) ON DELETE CASCADE,
    event_id UUID NOT NULL REFERENCES event(id) ON DELETE CASCADE,
    recommended_at TIMESTAMP DEFAULT NOW(),
    context TEXT, -- Store the conversation context that triggered this recommendation
    UNIQUE(user_id, event_id)
);
```

### 2. Data Structure Definitions

#### User Interests Format
```typescript
interface UserInterests {
  broad: string[];        // e.g., ["fitness", "social", "technology"]
  specific: string[];     // e.g., ["morning running", "coffee networking", "coding workshops"]
  scores: Record<string, number>; // Confidence scores 0-1
  lastUpdated: Date;
}
```

#### Event Keywords Format
```typescript
interface EventKeywords {
  keywords: string[];     // e.g., ["running", "fitness", "morning", "cardio", "outdoor"]
  scores: Record<string, number>; // Relevance scores 0-1
}
```

### 3. Implementation Components

#### A. Keyword Generation Script
**File**: `scripts/generate-event-keywords.ts`

**Purpose**: Extract keywords from existing events using AI
**Process**:
1. Fetch all events from database
2. Send event title + description to OpenAI
3. Request structured keyword extraction with relevance scores
4. Update database with keywords and scores

**AI Prompt**:
```
Extract relevant keywords from this event that would help match it to user interests.
Return as JSON: {
  "keywords": ["keyword1", "keyword2", ...],
  "scores": {"keyword1": 0.9, "keyword2": 0.7, ...}
}

Event: {title} - {description}
```

#### B. Enhanced Chat API
**File**: `app/api/chat/[...all]+api.ts`

**New Flow**:
1. Receive user message
2. Check if user has recent interests (within 24h)
3. If not, or if new information detected, run interest extraction
4. Perform semantic matching against events
5. Generate response with events (if relevant)
6. Update user interests and recommendation history

#### C. Interest Extraction Service
**File**: `lib/services/interest-extraction.ts`

**Purpose**: Extract and update user interests from conversation
**Features**:
- Analyze current message + recent context
- Update existing interests or add new ones
- Maintain confidence scores
- Handle interest conflicts/updates

#### D. Event Matching Service
**File**: `lib/services/event-matching.ts`

**Purpose**: Match user interests to events using AI-powered semantic similarity
**Algorithm**:
1. Use AI to calculate similarity scores between user interests and event keywords
2. Apply popularity weighting (attendees + interested)
3. Filter out previously recommended events
4. Return ranked results with similarity scores

**Similarity Calculation**:
```typescript
// For each user interest vs event keyword combination
const similarityPrompt = `
Rate the similarity between these interests (0-1):
User Interest: "${userInterest}"
Event Keywords: ${eventKeywords.join(', ')}

Consider related activities, synonyms, and broader categories.
Return only a number between 0 and 1.
`;
```

#### E. Chat UI Enhancement
**File**: `components/EventCard.tsx` (new reusable component)
**File**: `app/(tabs)/chat.tsx` (enhanced)

**Features**:
- Extract event card rendering logic from events page
- Support for inline event cards in chat
- Maintain identical styling to main events page

### 4. AI System Prompts

#### Interest Extraction Prompt
```
You are a helpful assistant analyzing user conversations to understand their interests and preferences for events.

Extract interests from this message and conversation context. Return as JSON:
{
  "newInterests": {
    "broad": ["category1", "category2"],
    "specific": ["specific_interest1", "specific_interest2"]
  },
  "confidence": 0.8,
  "shouldUpdate": true/false
}

Consider:
- Categories: fitness, social, creative, technology, education, food, music, outdoors, business
- Activity levels: beginner, intermediate, advanced
- Skill requirements: none, some experience, expert level
- Social preferences: group activities, solo activities, networking

Message: {userMessage}
Recent Context: {recentMessages}
```

#### Event Recommendation Prompt
```
You are a friendly event recommendation assistant. You know about all local events and want to help users find activities they'll enjoy.

When recommending events:
- Be conversational and enthusiastic
- Ask clarifying questions if too many events match (continue until you have 3 or fewer clear matches)
- Focus on category, activity level, and skill requirements
- Don't mention time/location (handled separately)
- Limit to 3 events maximum

If you have good matches, include them in your response like this:
<events>
[{"id": "event_id", "title": "Event Title", "description": "Description", "categories": ["category1"], "attendeesCount": 5, "interestedCount": 3, "location": {"neighborhood": "Area"}}]
</events>

If you don't have enough information about the user's interests, tell them you need to learn more about what they enjoy.

User Interests: {userInterests}
Available Events: {matchedEvents}
```

### 5. Implementation Steps

#### Phase 1: Database & Data Preparation
1. **Database Migrations**
   - Add keywords and scores to events table
   - Add interests and scores to user_profile table
   - Create event_recommendation table

2. **Keyword Generation**
   - Create and run keyword generation script
   - Populate keywords for all existing events
   - Validate keyword quality

#### Phase 2: Core Services
1. **Interest Extraction Service**
   - Implement interest analysis logic
   - Create user interest update functions
   - Add confidence scoring

2. **Event Matching Service**
   - Implement semantic matching algorithm
   - Add popularity weighting
   - Create recommendation tracking

#### Phase 3: API Enhancement
1. **Enhanced Chat API**
   - Integrate interest extraction
   - Add event matching logic
   - Implement structured responses

2. **Response Format**
   - Support mixed text/event responses
   - Handle clarifying questions
   - Manage recommendation history

#### Phase 4: UI Implementation
1. **Event Card Component**
   - Extract reusable component from events page
   - Ensure identical styling
   - Add chat-specific interactions

2. **Chat UI Enhancement**
   - Support event card rendering
   - Handle mixed message types
   - Maintain chat flow

### 6. Technical Considerations

#### Performance
- **Caching**: Cache user interests for 24h
- **Batch Processing**: Process keywords generation in batches
- **Indexing**: Add database indexes on keywords and interests
- **Query Optimization**: Use efficient semantic search queries

#### Scalability
- **Semantic Search**: Start with AI similarity scoring, upgrade to embeddings later
- **Rate Limiting**: Limit interest extraction frequency
- **Background Jobs**: Move keyword generation to background process
- **Caching**: Cache similarity scores for common interest/keyword combinations

#### Error Handling
- **No User Data**: Inform user we need more information about their interests
- **No Matches**: Show popular events as fallback
- **Partial Failures**: Continue chat even if event matching fails
- **Data Validation**: Validate AI responses before database updates

### 7. Testing Strategy

#### Unit Tests
- Interest extraction accuracy
- Event matching algorithm
- Keyword generation quality

#### Integration Tests
- End-to-end chat flow with events
- Database consistency
- API response formats

#### Manual Testing
- Conversation flow quality
- Event recommendation relevance
- UI consistency between chat and events page

### 8. Success Metrics

- **Relevance**: User engagement with recommended events
- **Accuracy**: Interest extraction precision
- **Performance**: Response time for event matching
- **User Experience**: Natural conversation flow

## Next Steps

1. **Database Migration**: Create and run migration scripts
2. **Keyword Generation**: Implement and run keyword extraction
3. **Core Services**: Build interest extraction and event matching
4. **API Enhancement**: Update chat API with new functionality
5. **UI Implementation**: Create reusable event card component
6. **Testing**: Comprehensive testing of all components
7. **Deployment**: Gradual rollout with monitoring

## Timeline Estimate

- **Phase 1**: 1 day (database + keywords)
- **Phase 2**: 1 day (core services)
- **Phase 3**: 0.5 day (API enhancement)
- **Phase 4**: 0.5 day (UI implementation)
- **Testing**: 0.5 day
- **Total**: 3.5 days (fits within 3-day constraint with some buffer)
