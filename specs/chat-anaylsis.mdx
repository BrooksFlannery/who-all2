# Chat Analysis & Event Recommendation System Technical Specification

## Overview

This document outlines the technical implementation of a chat analysis system that extracts user interests from conversations and provides personalized event recommendations using AI-powered analysis and semantic matching with **proper tool calls**.

## System Architecture

### Core Components

1. **Interest Extraction Tool** - AI tool that analyzes user messages for expressed interests
2. **Event Recommendation Tool** - AI tool that provides personalized event suggestions
3. **Database Schema Extensions** - New tables and fields for interest tracking
4. **AI Integration** - Vercel AI SDK with proper tool calls
5. **Unified Chat Flow** - Single streamText call with multiple tools

## Database Schema Changes

### New Tables Required

#### 1. `user_interest` Table
```sql
CREATE TABLE user_interest (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL REFERENCES user(id) ON DELETE CASCADE,
    keyword TEXT NOT NULL,
    confidence_score DECIMAL(3,2) NOT NULL CHECK (confidence_score >= 0 AND confidence_score <= 1),
    specificity_score DECIMAL(3,2) NOT NULL CHECK (specificity_score >= 0 AND specificity_score <= 1),
    source_message_id UUID REFERENCES message(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, keyword)
);
```

#### 2. `event_keyword` Table
```sql
CREATE TABLE event_keyword (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id UUID NOT NULL REFERENCES event(id) ON DELETE CASCADE,
    keyword TEXT NOT NULL,
    weight DECIMAL(3,2) DEFAULT 1.0 CHECK (weight >= 0 AND weight <= 1),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(event_id, keyword)
);
```

#### 3. `user_event_recommendation` Table
```sql
CREATE TABLE user_event_recommendation (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL REFERENCES user(id) ON DELETE CASCADE,
    event_id UUID NOT NULL REFERENCES event(id) ON DELETE CASCADE,
    recommendation_score DECIMAL(5,4) NOT NULL,
    shown_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    user_feedback TEXT, -- 'interested', 'not_interested', 'going', null
    UNIQUE(user_id, event_id)
);
```

### Schema Modifications

#### 1. Update `event` Table
Add keywords field to existing events:
```sql
ALTER TABLE event ADD COLUMN keywords TEXT[] DEFAULT '{}';
```

#### 2. Update `user_profile` Table
Add interest tracking fields:
```sql
ALTER TABLE user_profile ADD COLUMN last_interest_analysis TIMESTAMP WITH TIME ZONE;
ALTER TABLE user_profile ADD COLUMN interest_analysis_version INTEGER DEFAULT 1;
```

## AI Tool Implementation

### Tool 1: Extract Interests Tool

**Purpose**: Analyze user messages for expressed interests and store them in the database.

**Tool Definition**:
```typescript
extractInterests: tool({
    description: "Extract user interests from messages when users share hobbies, activities, or preferences. Call this to learn about what users enjoy.",
    parameters: z.object({
        userMessage: z.string().describe('The user message to analyze for interests'),
    }),
    execute: async ({ userMessage }) => {
        // 1. Use OpenAI to analyze message for interests
        // 2. Store interests in database
        // 3. Return summary of what was learned
    }
})
```

**Implementation**:
```typescript
async function extractUserInterests(message: string, userId: string, messageId: string): Promise<string> {
    // 1. Use OpenAI to analyze message for interests
    const result = await generateText({
        model: openai('gpt-4o-mini'),
        messages: [
            {
                role: 'system',
                content: `Analyze the following user message for expressed interests, hobbies, activities, or preferences. 
Return a JSON object with:
- interests: array of interest objects with keyword, confidence_score (0-1), and specificity_score (0-1)
- has_interests: boolean indicating if any interests were found

Guidelines:
- confidence_score: How certain you are this is an actual interest (not just mentioned)
- specificity_score: How specific/niche the interest is (e.g., "rock climbing" vs "sports")
- Extract both explicit ("I love hiking") and implicit ("I'm training for a marathon") interests
- Focus on activities, hobbies, skills, and preferences that could relate to events
- Ignore dislikes or negative preferences for now (MVP scope)

Message: "${message}"

Return only valid JSON.`
            }
        ]
    });

    // 2. Parse and store interests
    const parsed = JSON.parse(result.text);
    if (parsed.has_interests && parsed.interests.length > 0 && db) {
        for (const interest of parsed.interests) {
            await db.insert(userInterest).values({
                userId: userId,
                keyword: interest.keyword,
                confidenceScore: interest.confidence_score.toString(),
                specificityScore: interest.specificity_score.toString(),
                sourceMessageId: messageId
            });
        }
    }

    // 3. Return conversational summary
    if (parsed.has_interests && parsed.interests.length > 0) {
        const interests = parsed.interests.map(i => i.keyword).join(', ');
        return `I learned that you're interested in: ${interests}. I'll keep this in mind for future recommendations!`;
    } else {
        return `I didn't detect any specific interests in that message, but I'm here to learn more about what you enjoy!`;
    }
}
```

### Tool 2: Get Recommendations Tool

**Purpose**: Provide personalized event recommendations based on user interests.

**Tool Definition**:
```typescript
getRecommendations: tool({
    description: "Get personalized event recommendations when users ask for suggestions, events, or activities. Call this to provide relevant event suggestions.",
    parameters: z.object({
        userMessage: z.string().describe('The user message requesting recommendations'),
    }),
    execute: async ({ userMessage }) => {
        // 1. Fetch user interests and events
        // 2. Calculate similarity scores
        // 3. Return formatted recommendations
    }
})
```

**Implementation**:
```typescript
async function getEventRecommendations(userId: string, limit: number = 3): Promise<string> {
    // 1. Fetch user interests
    const userInterests = await db
        .select()
        .from(userInterest)
        .where(eq(userInterest.userId, userId));

    // 2. Fetch events (excluding previously shown)
    const events = await db
        .select()
        .from(event)
        .where(/* exclude shown events */);

    // 3. Calculate similarity scores using embeddings
    const scores = await calculateSimilarityScores(
        userInterests.map(i => i.keyword),
        events.map(e => e.keywords).flat()
    );

    // 4. Apply scoring formula and return top results
    const recommendations = events
        .map((event, index) => ({
            event,
            score: scores[index]
        }))
        .sort((a, b) => b.score - a.score)
        .slice(0, limit);

    // 5. Return conversational response
    if (recommendations.length > 0) {
        const eventList = recommendations.map(r => 
            `â€¢ ${r.event.title} - ${r.event.description}`
        ).join('\n');
        return `Here are some events that might interest you:\n\n${eventList}\n\nWould you like to know more about any of these?`;
    } else {
        return `I don't have any events to recommend right now, but I'm working on finding more activities that match your interests!`;
    }
}
```

## Unified Chat API Implementation

### Single streamText Call with Tools

```typescript
export async function POST(req: Request) {
    const session = await auth.api.getSession({ headers: req.headers });
    if (!session?.user?.id) {
        return new Response("Unauthorized", { status: 401 });
    }

    const { messages } = await req.json();
    
    // Save user message
    const [savedMessage] = await db.insert(message).values({
        userId: session.user.id,
        content: messages[messages.length - 1].content,
        role: "user"
    }).returning({ id: message.id });

    const result = streamText({
        model: openai('gpt-4o-mini'),
        messages: [
            {
                role: "system",
                content: `You are a friendly and helpful assistant that helps users discover events and activities. 

IMPORTANT GUIDELINES:
- Be conversational, warm, and engaging in your responses
- When users share their interests, hobbies, or activities, use the extractInterests tool to learn about them
- When users ask for recommendations, suggestions, or events, use the getRecommendations tool
- Ask follow-up questions to understand their preferences better
- Keep responses natural and conversational - don't sound like a robot
- Always acknowledge when you learn new interests about them

Your goal is to help users discover events that match their interests by having natural conversations and understanding what they enjoy.`
            },
            ...messages,
        ],
        tools: {
            extractInterests: tool({
                description: "Extract user interests from messages when users share hobbies, activities, or preferences. Call this to learn about what users enjoy.",
                parameters: z.object({
                    userMessage: z.string().describe('The user message to analyze for interests'),
                }),
                execute: async ({ userMessage }) => {
                    return extractUserInterests(userMessage, session.user.id, savedMessage.id);
                }
            }),
            getRecommendations: tool({
                description: "Get personalized event recommendations when users ask for suggestions, events, or activities. Call this to provide relevant event suggestions.",
                parameters: z.object({
                    userMessage: z.string().describe('The user message requesting recommendations'),
                }),
                execute: async ({ userMessage }) => {
                    return getEventRecommendations(session.user.id, 3);
                }
            })
        },
        onFinish: async (completion) => {
            // Save AI response
            await db.insert(message).values({
                userId: session.user.id,
                content: completion.text,
                role: "assistant"
            });
        },
    });

    return result.toDataStreamResponse();
}
```

## Data Flow

### Natural Conversation Flow
1. User sends message
2. Message saved to database
3. AI analyzes message and decides what tools to call
4. If interests detected â†’ calls extractInterests tool
5. If recommendations requested â†’ calls getRecommendations tool
6. AI responds conversationally with tool results
7. AI response saved to database

### Tool Call Examples

**User says:** "I love rock climbing and hiking"
```
AI: "That's awesome! I love that you're into outdoor activities. I learned that you're interested in: rock climbing, hiking. I'll keep this in mind for future recommendations!"
```

**User says:** "Can you recommend some events?"
```
AI: "Absolutely! Here are some events that might interest you:

â€¢ Morning Running Club - Join our weekly running group! All paces welcome.
â€¢ Outdoor Adventure Meetup - Hiking and rock climbing for all skill levels.
â€¢ Weekend Hiking Group - Explore local trails with fellow outdoor enthusiasts.

Would you like to know more about any of these?"
```

## Implementation Phases

### Phase 1: Database Setup
1. Create database migrations
2. Manually assign keywords to seed events
3. Test database schema

### Phase 2: Core Functions
1. Implement extractUserInterests function
2. Implement getEventRecommendations function
3. Add embedding functionality

### Phase 3: Tool Integration
1. Replace current chat API with unified tool-based approach
2. Test tool calls and responses
3. Verify conversation flow

### Phase 4: Optimization
1. Add caching for embeddings
2. Optimize recommendation algorithm
3. Add user feedback collection

## Key Benefits of Tool-Based Approach

1. **Natural conversation flow** - AI decides when to extract interests or get recommendations
2. **No hardcoded logic** - No more `includes('recommend')` bullshit
3. **Single code path** - One streamText call handles everything
4. **Better user experience** - AI can extract interests naturally during conversation
5. **Easier to extend** - Just add new tools as needed
6. **Cleaner code** - Each tool has one job, clear separation of concerns

## Error Handling

### Tool Execution Errors
- Graceful degradation if tools fail
- Fallback responses for recommendation failures
- Log errors for debugging

### Conversation Flow
- AI handles edge cases naturally
- No manual flow control needed
- Tool calls are optional and contextual

## Testing Strategy

### Tool Testing
- Test each tool independently
- Verify database operations
- Test error scenarios

### Integration Testing
- End-to-end conversation flow
- Tool call integration
- Natural language understanding

### User Testing
- Interest detection accuracy
- Recommendation relevance
- Conversation naturalness
