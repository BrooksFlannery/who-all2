# Google Places API Integration Spec for Event Generation

## Overview
This spec covers the final step in the who-all event generation pipeline: converting pseudo-events (generated from user interest clusters) into real events with actual venues from Google Places API.

## Context in Project Flow
1. **User Interest Analysis** → System analyzes chat data to build interest profiles
2. **Pseudo-Event Generation** → Creates event concepts based on interest clusters (not covered here)
3. **Google Places API** → Finds real venues matching pseudo-event criteria (this spec)
4. **Real Events** → Stored in existing `event` table with venue data

## Input: Pseudo-Event Interface
```typescript
interface PseudoEvent {
  title: string;                    // e.g. "Rock Climbing Meetup"
  description: string;              // Event description
  categories: string[];             // Event categories: ["fitness", "social"]
  targetLocation: {
    center: { lat: number; lng: number };
    radiusMeters: number;           // e.g. 5000 (5km)
  };
  venueTypeQuery: string;           // e.g. "rock climbing gym", "coffee shop" (precise description)
  googleVenueTypes: string[];       // e.g. ["gym"], ["cafe", "coffee_shop"] (Google Places API types)
  venueTypeConfidence: number;      // e.g. 0.85 (confidence in semantic mapping)
  estimatedAttendees: number;       // Expected group size
}
```

**Note**: The `googleVenueTypes` field is populated by semantic matching against Google Places API types using embeddings. This allows for precise venue type mapping while maintaining the specificity of the original `venueTypeQuery`.

## Database Schema Updates
### Enhanced Event Table
```typescript
export const event = pgTable("event", {
  // Existing fields...
  id: uuid("id").defaultRandom().primaryKey(),
  title: text("title").notNull(),
  date: timestamp("date", { withTimezone: true }).notNull(),
  location: jsonb("location").notNull(), // { lat: number, lng: number, neighborhood?: string }
  description: text("description").notNull(),
  categories: text("categories").array().notNull(), // Event categories (fitness, social, etc.)
  
  // New Google Places fields
  venue: jsonb("venue"),                    // Google Places venue data
  venueType: text("venue_type"),            // Google type (gym, restaurant, park)
  venueRating: integer("venue_rating"),     // Google rating (1-5)
  venuePriceLevel: integer("venue_price_level"), // Google price level (1-4)
  
  // Existing fields...
  hostId: text("host_id").references(() => user.id),
  embedding: text("embedding"), // VECTOR(1536)
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
  attendeesCount: integer("attendees_count").default(0).notNull(),
  interestedCount: integer("interested_count").default(0).notNull(),
});
```

### User Location (Simplified Approach)
```typescript
// Add to existing user table (already implemented in pseudo-events spec)
export const user = pgTable("user", {
  // ... existing fields ...
  location: jsonb("location"), // { lat: number, lng: number } - nullable
  // ... rest of existing fields ...
});
```

**Note**: Using single location field on user table instead of separate user_location table for MVP simplicity. This avoids complexity while meeting requirements.

## Google Places API Integration

### 1. Search Parameters
```typescript
interface VenueSearchParams {
  pseudoEvent: PseudoEvent;
  maxResults?: number;        // Default: 20
  maxDetailFetches?: number;  // Default: 10
  scoreThreshold?: number;    // Default: 0.5 (0-1)
  apiKey: string;            // From .env GOOGLE_PLACES_API_KEY
}
```

### 2. Venue Selection Strategy
**Nearby Search Approach**
- Use Google Places Nearby Search API
- Requires center + radius (matches our pseudo-event targetLocation)
- Returns up to 20 results ordered by distance
- Best for our use case since we have specific target areas

**Enhanced Scoring Algorithm**
- Score = (normalized distance × DISTANCE_WEIGHT) + (normalized rating × RATING_WEIGHT) + (venue type match × VENUE_TYPE_WEIGHT)
- Distance score: 1 - (candidate index / total candidates)
- Rating score: (Google rating / 5)
- Venue type match: Check if venue name/types contain keywords from venueTypeQuery
- Only venues above scoreThreshold are considered

**Scoring Weights (Global Variables):**
- `DISTANCE_WEIGHT`: 0.4 (40% weight for distance)
- `RATING_WEIGHT`: 0.4 (40% weight for venue rating)
- `VENUE_TYPE_WEIGHT`: 0.2 (20% weight for venue type match)
- `SCORE_THRESHOLD`: 0.5 (minimum score to consider a venue)

### 3. Implementation Steps

#### 3.1 Nearby Search Call
```typescript
async function searchNearby(params: VenueSearchParams) {
  const body = {
    includedTypes: params.pseudoEvent.googleVenueTypes,  // Use semantic-matched types
    locationRestriction: {
      circle: {
        center: params.pseudoEvent.targetLocation.center,
        radius: params.pseudoEvent.targetLocation.radiusMeters
      }
    },
    maxResultCount: params.maxResults || 20,
    rankPreference: 'DISTANCE'
  };

  const res = await axios.post(
    'https://places.googleapis.com/v1/places:searchNearby',
    body,
    {
      headers: {
        'X-Goog-Api-Key': params.apiKey,
        'X-Goog-FieldMask': [
          'places.id',
          'places.displayName',
          'places.location',
          'places.types'
        ].join(',')
      }
    }
  );
  return res.data.places;
}
```

#### 3.2 Enhanced Scoring with Venue Type Filtering
```typescript
async function findBestVenue(params: VenueSearchParams) {
  const candidates = await searchNearby(params);
  
  // Score each candidate with venue type filtering
  for (let i = 0; i < candidates.length; i++) {
    const candidate = candidates[i];
    
    // Calculate venue type match score
    const venueTypeScore = calculateVenueTypeMatch(
      candidate.displayName.text,
      candidate.types,
      params.pseudoEvent.venueTypeQuery
    );
    
    // Score = (normalized distance * DISTANCE_WEIGHT) + (normalized rating * RATING_WEIGHT) + (venue type match * VENUE_TYPE_WEIGHT)
    const distanceScore = 1 - i / Math.max(candidates.length - 1, 1);
    const ratingScore = (candidate.rating ?? 0) / 5;
    const score = DISTANCE_WEIGHT * distanceScore + RATING_WEIGHT * ratingScore + VENUE_TYPE_WEIGHT * venueTypeScore;

    candidate.score = score;

    if (score >= (params.scoreThreshold ?? SCORE_THRESHOLD)) {
      return candidate;
    }
  }

  return null; // no venue met criteria
}

function calculateVenueTypeMatch(venueName: string, venueTypes: string[], targetQuery: string): number {
  const name = venueName.toLowerCase();
  const query = targetQuery.toLowerCase();
  
  // Check if venue name contains target keywords
  const nameMatch = query.split(' ').some(word => 
    word.length > 3 && name.includes(word)
  ) ? 1.0 : 0.0;
  
  // Check if venue types are relevant
  const typeMatch = venueTypes.some(type => 
    query.includes(type.replace('_', ' '))
  ) ? 0.8 : 0.0;
  
  return Math.max(nameMatch, typeMatch);
}
```

### 4. Event Generation Process
```typescript
async function generateRealEvent(pseudoEvent: PseudoEvent): Promise<Event | null> {
  const apiKey = process.env.GOOGLE_PLACES_API_KEY;
  
  // Step 1: Find best venue using enhanced scoring
  const venue = await findBestVenue({
    pseudoEvent,
    apiKey
  });
  
  if (!venue) return null;
  
  // Step 2: Generate random time (MVP - timing logic to be refined later)
  const eventTime = generateRandomTime();
  
  // Step 3: Create real event
  return {
    title: pseudoEvent.title,
    description: pseudoEvent.description,
    categories: pseudoEvent.categories,
    date: eventTime,
    location: {
      lat: venue.location.latitude,
      lng: venue.location.longitude,
      neighborhood: extractNeighborhood(venue.displayName.text)
    },
    venue: {
      placeId: venue.id,
      name: venue.displayName.text,
      types: venue.types
    },
    venueType: venue.types[0],
    venueRating: venue.rating,
    venuePriceLevel: venue.priceLevel,
    hostId: null, // System-generated
    embedding: null, // Generated after creation
    attendeesCount: 0,
    interestedCount: 0
  };
}
```

## API Integration Notes

**Note**: Event generation is handled through the existing pseudo-event generation pipeline and direct function calls. No additional API endpoints are needed for the MVP implementation.

## Cost Analysis
- **Free Tier**: 5,000 Search + 5,000 Details/month
- **Per Event**: 1 Nearby Search + up to 10 Details
- **Monthly Budget**: ~330 API calls for 1 event/day with 10 venue checks
- **Cost**: Fully covered by free tier for MVP

## Environment Setup
Add to `.env`:
```
GOOGLE_PLACES_API_KEY=your_api_key_here
```

## Key Implementation Notes

### 1. **Global Configuration Variables**
```typescript
// Venue scoring weights (should sum to 1.0)
export const DISTANCE_WEIGHT = 0.4;      // 40% weight for distance
export const RATING_WEIGHT = 0.4;        // 40% weight for venue rating  
export const VENUE_TYPE_WEIGHT = 0.2;    // 20% weight for venue type match

// Venue selection thresholds
export const SCORE_THRESHOLD = 0.5;      // Minimum score to consider a venue
export const VENUE_TYPE_MATCH_THRESHOLD = 0.3; // Minimum venue type match score

// Search parameters
export const DEFAULT_MAX_RESULTS = 20;   // Default max venues to search
export const DEFAULT_MAX_DETAIL_FETCHES = 10; // Default max venues to check details
```

### 2. **Semantic Venue Type Matching**
- Pseudo-events now include `googleVenueTypes` field populated by semantic matching
- Uses embeddings to find closest Google Places API types
- Maintains specificity of original `venueTypeQuery` for post-filtering
- Confidence scoring helps adjust search parameters

### 2. **Enhanced Venue Selection**
- Distance + rating + venue type match scoring algorithm
- Post-filtering using precise venue type query
- Configurable thresholds for quality control
- Graceful fallback when no suitable venues found

### 3. **Data Flow**
- Pseudo-events from clustering pipeline with semantic venue types
- Real venues from Google Places API using matched types
- Enhanced event records with venue metadata
- Maintains existing event table structure

### 4. **Location Handling**
- Uses simplified user location (single JSONB field)
- Default to Manhattan for users without location
- Cluster centroids calculated from user locations
- 5km radius for venue search (configurable)

## Key Distinctions
- **Event Categories**: User-facing categories (fitness, social, creative) - separate from venue types
- **Venue Types**: Google Places types (gym, restaurant, park) - used for venue selection only
- **Venue Type Query**: Precise description for post-filtering and scoring
- **Location**: Enhanced with Google Places data but maintains existing format
- **Timing**: MVP uses random times; venue availability logic to be added later

## Implementation Plan

### Phase 1: Foundation
1. Set up Google Places API key
2. Install axios for HTTP requests
3. Create venue search functions with semantic matching
4. Test with sample coordinates

### Phase 2: Integration
1. Create event generation endpoint
2. Implement enhanced venue scoring algorithm
3. Add error handling and fallbacks
4. Test with pseudo-event data

### Phase 3: Production
1. Add user location endpoint
2. Implement automated triggers
3. Add monitoring and logging
4. Optimize for scale

## Next Steps
1. Update database schema with new venue fields
2. Implement semantic venue type matching system
3. Create enhanced venue search and scoring functions
4. Create event generation API endpoint
5. Add user location management
6. Integrate with pseudo-event generation pipeline
7. Add venue availability timing logic (future enhancement)

## ✅ Implementation Status

**COMPLETED: Semantic Venue Type Matching System**

The semantic venue type matching system has been fully implemented:

1. **✅ Google Places Types Database**: Complete list of 301 Google Places API types with embeddings
2. **✅ Semantic Matching Function**: `findBestVenueTypes()` with cosine similarity matching
3. **✅ Confidence Scoring**: Calculates confidence in semantic mapping
4. **✅ Integration with Pseudo-Event Generation**: Fully integrated with venue type extraction

**Implementation Details:**
- ✅ Uses OpenAI embeddings for semantic matching
- ✅ Stores Google Places types in code for performance
- ✅ Supports multiple venue types when semantic similarity is close
- ✅ Implements confidence threshold for mapping quality
- ✅ Fallback to keyword matching for low-confidence cases
- ✅ **Global configuration variables** for scoring weights and thresholds
- ✅ **Configurable scoring algorithm** through constants

**Current Performance:**
- Semantic matching works well for general venue types (coffee shop, restaurant, etc.)
- Specific activity venues (like "rock climbing gym") need improvement
- Confidence scores range from 56% to 100% depending on query specificity

# Current Issues and Deep Dive Plan

## Problem Statement
- When searching for specific venue types (e.g., "rock climbing gym"), the system consistently returns irrelevant or generic venues (e.g., pilates studios, generic gyms) instead of highly relevant matches.
- The scores for these matches are low, but the system still returns them as the "best" available, even when the match is not appropriate.
- The same irrelevant venues are returned repeatedly for specific queries, undermining trust in the recommendation system.

## Root Cause Analysis (Based on Logging)
**Primary Issue: Venue Type Matching Algorithm**
- The venue type matching algorithm only looks for exact word matches between query words and venue types
- "rock climbing gym" → ["rock", "climbing"] → No matches found in venue types like "gym", "fitness_center"
- All venues get 0% venue type match score, relying only on distance and rating

**Secondary Issue: Google Places API Limitations**
- Google Places API doesn't have specific types for activities like "rock climbing"
- Only generic types like "gym", "fitness_center", "sports_complex" are available
- The API returns all gyms in the area, regardless of specific activities offered

**Tertiary Issue: Scoring Threshold**
- Minimum score threshold (30%) is too low, allowing poor matches to be selected
- System selects venues with 0% venue type match as long as they have good distance/rating

## Investigation/Improvement Plan
- **✅ Add comprehensive logging:** COMPLETED - Now shows detailed analysis of each venue
- **Improve venue type matching:** Enhance algorithm to handle compound terms and synonyms
- **Add activity-specific filtering:** Use venue names and descriptions to filter for specific activities
- **Increase scoring thresholds:** Require minimum venue type match scores
- **Consider alternative APIs:** Explore Google Places Text Search for more specific queries
- **Add venue name analysis:** Parse venue names for activity keywords (e.g., "climbing", "yoga", "pilates")